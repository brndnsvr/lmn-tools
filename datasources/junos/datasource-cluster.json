{
  "description": "Monitors SRX chassis cluster HA status including redundancy groups, control/fabric links, failover events, and peer reachability.",
  "group": "Juniper",
  "appliesTo": "hasCategory(\"Juniper\") && system.sysinfo =~ \"SRX\" && auto.cluster_mode == \"true\"",
  "technology": "Requires SNMP access. Automatically detects cluster mode via PropertySource. Monitors jnxJsChassisClusterMIB and jnxJsRedundancyGroupTable.",
  "tags": "juniper,srx,chassis-cluster,high-availability,firewall",
  "name": "Juniper_SRX_ChassisCluster",
  "displayName": "SRX Chassis Cluster",
  "hasMultiInstances": true,
  "useWildValueAsUUID": true,
  "collectInterval": 60,
  "collectMethod": "batchscript",
  "collectorAttribute": {
    "name": "batchscript",
    "groovyScript": "// Juniper SRX Chassis Cluster Collection Script\\nimport com.santaba.agent.groovyapi.snmp.Snmp\\n\\ndef hostname = hostProps.get('system.hostname')\\ndef timeout = 15000\\ndef snmpVersion = hostProps.get('snmp.version') ?: 'v2c'\\ndef community = hostProps.get('snmp.community') ?: 'public'\\n\\n// Build SNMPv3 params if needed\\ndef snmpV3Params = null\\ndef isV3 = (snmpVersion == 'v3' || snmpVersion == '3')\\nif (isV3) {\\n    snmpV3Params = [\\n        version: 3,\\n        port: hostProps.get('snmp.port')?.toInteger() ?: 161,\\n        timeout: timeout,\\n        securityName: hostProps.get('snmp.security'),\\n        authProtocol: hostProps.get('snmp.auth'),\\n        authPassword: hostProps.get('snmp.authToken'),\\n        privProtocol: hostProps.get('snmp.priv'),\\n        privPassword: hostProps.get('snmp.privToken')\\n    ]\\n}\\n\\n// Helper function to do SNMP get\\n// v2c signature: get(hostname, oid, community, version, timeout)\\n// v3 signature: get(hostname, oid, map, timeout)\\ndef snmpGet = { oid ->\\n    if (isV3) {\\n        return Snmp.get(hostname, oid, snmpV3Params, timeout)\\n    } else {\\n        return Snmp.get(hostname, oid, community, snmpVersion, timeout)\\n    }\\n}\\n\\n// Helper function to do SNMP walk\\ndef snmpWalk = { oid ->\\n    if (isV3) {\\n        return Snmp.walk(hostname, oid, snmpV3Params, timeout)\\n    } else {\\n        return Snmp.walk(hostname, oid, community, snmpVersion, timeout)\\n    }\\n}\\n\\n// jnxJsChassisClusterMIB OIDs\\ndef oids = [\\n    controlLink:     '.1.3.6.1.4.1.2636.3.39.1.13.1.1.1.5',\\n    fabricLink:      '.1.3.6.1.4.1.2636.3.39.1.13.1.1.1.6',\\n    peerStatus:      '.1.3.6.1.4.1.2636.3.39.1.13.1.1.1.7',\\n    failoverCount:   '.1.3.6.1.4.1.2636.3.39.1.13.1.1.1.8',\\n    rgStatus:        '.1.3.6.1.4.1.2636.3.39.1.13.2.1.1.3',\\n    rgWeight:        '.1.3.6.1.4.1.2636.3.39.1.13.2.1.1.5',\\n    rgPreempt:       '.1.3.6.1.4.1.2636.3.39.1.13.2.1.1.6',\\n    monitorFailures: '.1.3.6.1.4.1.2636.3.39.1.13.2.1.1.7'\\n]\\n\\n// Maps to store per-RG values\\ndef rgStatusMap = [:]\\ndef rgWeightMap = [:]\\ndef rgPreemptMap = [:]\\ndef monitorFailuresMap = [:]\\n\\ntry {\\n    // Get cluster-level metrics (scalar OIDs with .0 suffix)\\n    def controlLink = snmpGet(oids.controlLink + '.0') ?: '0'\\n    def fabricLink = snmpGet(oids.fabricLink + '.0') ?: '0'\\n    def peerStatus = snmpGet(oids.peerStatus + '.0') ?: '0'\\n    def failoverCount = snmpGet(oids.failoverCount + '.0') ?: '0'\\n    \\n    // Determine overall cluster health (1=healthy if all links up and peer reachable)\\n    def clusterHealthy = (controlLink == '1' && fabricLink == '1' && peerStatus == '1') ? 1 : 0\\n    \\n    // Walk RG tables for per-RG metrics\\n    def rgStatusWalk = snmpWalk(oids.rgStatus)\\n    rgStatusWalk?.each { row ->\\n        def oid = row[0]?.toString()\\n        def index = oid?.tokenize('.')?.last()\\n        rgStatusMap[index] = row[1]\\n    }\\n    \\n    def rgWeightWalk = snmpWalk(oids.rgWeight)\\n    rgWeightWalk?.each { row ->\\n        def oid = row[0]?.toString()\\n        def index = oid?.tokenize('.')?.last()\\n        rgWeightMap[index] = row[1]\\n    }\\n    \\n    def rgPreemptWalk = snmpWalk(oids.rgPreempt)\\n    rgPreemptWalk?.each { row ->\\n        def oid = row[0]?.toString()\\n        def index = oid?.tokenize('.')?.last()\\n        rgPreemptMap[index] = row[1]\\n    }\\n    \\n    def monitorWalk = snmpWalk(oids.monitorFailures)\\n    monitorWalk?.each { row ->\\n        def oid = row[0]?.toString()\\n        def index = oid?.tokenize('.')?.last()\\n        monitorFailuresMap[index] = row[1]\\n    }\\n    \\n    // Output cluster-wide metrics\\n    println \\\"cluster.ClusterHealthy=${clusterHealthy}\\\"\\n    println \\\"cluster.ControlLinkUp=${controlLink}\\\"\\n    println \\\"cluster.FabricLinkUp=${fabricLink}\\\"\\n    println \\\"cluster.PeerReachable=${peerStatus}\\\"\\n    println \\\"cluster.TotalFailovers=${failoverCount}\\\"\\n    \\n    // Output per-RG metrics\\n    rgStatusMap.each { index, status ->\\n        def wildvalue = \\\"rg${index}\\\"\\n        def weight = rgWeightMap[index] ?: '0'\\n        def preempt = rgPreemptMap[index] ?: '0'\\n        def monitorFail = monitorFailuresMap[index] ?: '0'\\n        \\n        println \\\"${wildvalue}.RGStatus=${status}\\\"\\n        println \\\"${wildvalue}.RGWeight=${weight}\\\"\\n        println \\\"${wildvalue}.Preempt=${preempt}\\\"\\n        println \\\"${wildvalue}.MonitorFailures=${monitorFail}\\\"\\n    }\\n} catch (Exception e) {\\n    println \\\"Error: ${e.class.simpleName} - ${e.message}\\\"\\n    e.printStackTrace()\\n}\\n\\nreturn 0",
    "scriptType": "embed",
    "linuxCmdline": "",
    "linuxScript": "",
    "windowsCmdline": "",
    "windowsScript": ""
  },
  "enableAutoDiscovery": true,
  "autoDiscoveryConfig": {
    "persistentInstance": true,
    "disableInstance": false,
    "deleteInactiveInstance": false,
    "showDeletedInstanceDays": 0,
    "instanceAutoGroupMethod": "none",
    "instanceAutoGroupMethodParams": "",
    "scheduleInterval": 60,
    "method": {
      "name": "ad_script",
      "type": "embeded",
      "groovyScript": "/*******************************************************************************\n * Juniper SRX Chassis Cluster Discovery Script\n * Discovers cluster-level instance and per-RG instances\n ******************************************************************************/\n\nimport com.santaba.agent.groovyapi.snmp.Snmp\n\ndef hostname = hostProps.get('system.hostname')\ndef timeout = 15000\ndef snmpVersion = hostProps.get('snmp.version') ?: 'v2c'\ndef community = hostProps.get('snmp.community') ?: 'public'\n\n// Build SNMPv3 params if needed\ndef snmpV3Params = null\ndef isV3 = (snmpVersion == 'v3' || snmpVersion == '3')\nif (isV3) {\n    snmpV3Params = [\n        version: 3,\n        port: hostProps.get('snmp.port')?.toInteger() ?: 161,\n        timeout: timeout,\n        securityName: hostProps.get('snmp.security'),\n        authProtocol: hostProps.get('snmp.auth'),\n        authPassword: hostProps.get('snmp.authToken'),\n        privProtocol: hostProps.get('snmp.priv'),\n        privPassword: hostProps.get('snmp.privToken')\n    ]\n}\n\n// Helper function to do SNMP walk\ndef snmpWalk = { oid ->\n    if (isV3) {\n        return Snmp.walk(hostname, oid, snmpV3Params, timeout)\n    } else {\n        return Snmp.walk(hostname, oid, community, snmpVersion, timeout)\n    }\n}\n\n// jnxJsRedundancyGroupTable: .1.3.6.1.4.1.2636.3.39.1.13.2.1\ndef rgTableOid = '.1.3.6.1.4.1.2636.3.39.1.13.2.1.1.2'\ndef rgIndices = []\n\ntry {\n    def rgWalk = snmpWalk(rgTableOid)\n    rgWalk?.each { row ->\n        def oid = row[0]?.toString()\n        def index = oid?.tokenize('.')?.last()\n        if (index && !rgIndices.contains(index)) {\n            rgIndices << index\n        }\n    }\n} catch (Exception e) {\n    // Default to RG0 and RG1 if walk fails\n    rgIndices = ['0', '1']\n}\n\n// If no RGs discovered, use defaults\nif (rgIndices.isEmpty()) {\n    rgIndices = ['0', '1']\n}\n\n// Output cluster-level instance first\nprintln \"cluster##Cluster Health##Cluster-wide health metrics####auto.instance.type=cluster\"\n\n// Output per-RG instances\nrgIndices.each { index ->\n    def rgType = (index == '0') ? 'control' : 'data'\n    def rgName = (index == '0') ? 'Control Plane (RG0)' : \"Data Plane (RG${index})\"\n    println \"rg${index}##${rgName}##Redundancy Group ${index}####auto.rg.id=${index}&auto.rg.type=${rgType}\"\n}\n\nreturn 0",
      "winScript": null,
      "winCmdline": null,
      "linuxCmdline": null,
      "linuxScript": null
    },
    "filters": []
  },
  "dataPoints": [
    {
      "name": "ClusterHealthy",
      "description": "Overall cluster health (1=healthy, 0=degraded). Healthy when control link, fabric link, and peer are all up.",
      "alertTransitionInterval": 1,
      "alertClearTransitionInterval": 3,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.ClusterHealthy",
      "rawDataFieldName": "output",
      "maxValue": "1",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "!= 1",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": "The SRX chassis cluster on ##HOST## is in a degraded state. High availability is compromised.\n\nCheck control links, fabric links, and peer reachability.\n\nThis started at ##START##, -- or ##DURATION## ago."
    },
    {
      "name": "ControlLinkUp",
      "description": "Control link status (1=up, 0=down). Critical for cluster heartbeat.",
      "alertTransitionInterval": 1,
      "alertClearTransitionInterval": 3,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.ControlLinkUp",
      "rawDataFieldName": "output",
      "maxValue": "1",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "!= 1",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": "CRITICAL: The chassis cluster control link is down on ##HOST##.\n\nRisk of split-brain scenario. Immediate attention required.\n\nThis started at ##START##, -- or ##DURATION## ago."
    },
    {
      "name": "FabricLinkUp",
      "description": "Fabric link status (1=up, 0=down). Required for session synchronization.",
      "alertTransitionInterval": 1,
      "alertClearTransitionInterval": 3,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.FabricLinkUp",
      "rawDataFieldName": "output",
      "maxValue": "1",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "!= 1",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": "CRITICAL: The chassis cluster fabric link is down on ##HOST##.\n\nSession synchronization is broken. Failover will cause session drops.\n\nThis started at ##START##, -- or ##DURATION## ago."
    },
    {
      "name": "PeerReachable",
      "description": "Peer node reachability (1=reachable, 0=unreachable).",
      "alertTransitionInterval": 1,
      "alertClearTransitionInterval": 3,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.PeerReachable",
      "rawDataFieldName": "output",
      "maxValue": "1",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "!= 1",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": "CRITICAL: The cluster peer node is unreachable from ##HOST##.\n\nCheck physical connectivity, peer node health, and control/fabric links.\n\nThis started at ##START##, -- or ##DURATION## ago."
    },
    {
      "name": "TotalFailovers",
      "description": "Total failover count since last clear. Use derive for failover rate.",
      "alertTransitionInterval": 0,
      "alertClearTransitionInterval": 0,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.TotalFailovers",
      "rawDataFieldName": "output",
      "maxValue": "",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": ""
    },
    {
      "name": "RGStatus",
      "description": "Redundancy group status (1=primary, 2=secondary-hold, 3=secondary).",
      "alertTransitionInterval": 0,
      "alertClearTransitionInterval": 0,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.RGStatus",
      "rawDataFieldName": "output",
      "maxValue": "3",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": ""
    },
    {
      "name": "RGWeight",
      "description": "Current redundancy group weight (priority minus penalties).",
      "alertTransitionInterval": 0,
      "alertClearTransitionInterval": 0,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.RGWeight",
      "rawDataFieldName": "output",
      "maxValue": "",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": ""
    },
    {
      "name": "Preempt",
      "description": "Preemption enabled (1=yes, 0=no).",
      "alertTransitionInterval": 0,
      "alertClearTransitionInterval": 0,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.Preempt",
      "rawDataFieldName": "output",
      "maxValue": "1",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": ""
    },
    {
      "name": "MonitorFailures",
      "description": "Count of active interface/IP monitor failures. May trigger failover.",
      "alertTransitionInterval": 1,
      "alertClearTransitionInterval": 3,
      "type": 2,
      "dataType": 7,
      "maxDigits": 4,
      "postProcessorMethod": "namevalue",
      "postProcessorParam": "##WILDVALUE##.MonitorFailures",
      "rawDataFieldName": "output",
      "maxValue": "",
      "minValue": "0",
      "userParam1": "",
      "userParam2": "",
      "userParam3": "",
      "alertForNoData": 1,
      "alertExpr": "> 0",
      "alertExprNote": "",
      "alertSubject": "",
      "alertBody": "##VALUE## monitor failure(s) detected on ##HOST## for ##INSTANCE##.\n\nThis may trigger a failover if threshold is exceeded.\n\nThis started at ##START##, -- or ##DURATION## ago."
    }
  ]
}

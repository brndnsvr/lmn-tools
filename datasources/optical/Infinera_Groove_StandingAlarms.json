{
  "collectionMethod": "snmp",
  "datapoints": [
    {
      "max": "11100",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "Alarm condition code per CORIANT-GROOVE-MIB. Common values: 17=linkdown, 18=los, 19=lol, 20=lofOtu, 100=oog, 106=autoshutoff. See MIB CoriantFmtypesConditionType for full enum.",
      "interpretMethod": "none",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "Rx5p8nofRLC9_1BMO2w9Lg",
      "min": "1",
      "name": "ConditionType",
      "noData": "Do not trigger an alert",
      "config": {
        "oid": ".1.3.6.1.4.1.42229.1.2.1.6.1.1.2.##WILDVALUE##"
      },
      "statusDisplayNames": []
    },
    {
      "max": "2",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "Whether alarm impacts traffic: 1=NSA (non-service-affecting), 2=SA (service-affecting)",
      "interpretMethod": "none",
      "threshold": ">= 2 2 2",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "LtVgska_QUiXuQDSbNZygQ",
      "min": "1",
      "name": "ServiceAffecting",
      "noData": "Do not trigger an alert",
      "config": {
        "oid": ".1.3.6.1.4.1.42229.1.2.1.6.1.1.6.##WILDVALUE##"
      },
      "statusDisplayNames": []
    },
    {
      "max": "6",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "Alarm severity: 1=cleared, 2=indeterminate, 3=warning, 4=minor, 5=major, 6=critical",
      "interpretMethod": "none",
      "threshold": ">= 4 5 6",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "q800A2DyQt-dQDcuI3lh1Q",
      "min": "1",
      "name": "SeverityLevel",
      "noData": "Do not trigger an alert",
      "config": {
        "oid": ".1.3.6.1.4.1.42229.1.2.1.6.1.1.7.##WILDVALUE##"
      },
      "statusDisplayNames": []
    }
  ],
  "searchKeywords": "alarm,dx,infinera,optical",
  "displayedAs": "Standing Alarms",
  "description": "Monitors active/standing alarms on Infinera Groove G30 optical transport systems",
  "appliesTo": "hasCategory(\"InfineraGroove\")",
  "activeDiscovery": {
    "deleteInactiveInstances": true,
    "groupMethod": "none",
    "discoveryMethod": "ad_script",
    "autoDeleteInstances": false,
    "disableDiscoveredInstances": false,
    "filters": [],
    "params": {
      "type": "groovy",
      "content": "/*\n * Infinera Groove Standing Alarms - Active Discovery Script v7\n * \n * Fixed: Index starts at tableOidLen + 3 (table.entry.column.columnIndex.INDEX)\n */\n\nimport com.santaba.agent.groovyapi.snmp.Snmp\n\ndef host = hostProps.get(\"system.hostname\")\n\ndef fmEntityOid = \"1.3.6.1.4.1.42229.1.2.1.6.1.1.1\"\ndef descriptionOid = \"1.3.6.1.4.1.42229.1.2.1.6.1.1.9\"\n\ndef fmEntityData\ndef descriptionData\n\ntry {\n    fmEntityData = Snmp.walkAsMap(host, fmEntityOid, null)\n    descriptionData = Snmp.walkAsMap(host, descriptionOid, null)\n} catch (Exception e) {\n    println \"SNMP walk failed: ${e.message}\"\n    return 1\n}\n\nif (!fmEntityData || fmEntityData.isEmpty()) {\n    return 0\n}\n\n/**\n * Detects entity type and returns [type, patternPartCount]\n */\ndef detectEntityType(String oidValue) {\n    if (!oidValue) return [\"unknown\", 0]\n    \n    def patterns = [\n        [\"1.3.6.1.4.1.42229.1.2.3.1\", \"shelf\", 11],\n        [\"1.3.6.1.4.1.42229.1.2.3.2\", \"card\", 11],\n        [\"1.3.6.1.4.1.42229.1.2.3.5\", \"subcard\", 11],\n        [\"1.3.6.1.4.1.42229.1.2.3.8\", \"pluggable\", 11],\n        [\"1.3.6.1.4.1.42229.1.2.4.1.1\", \"100gbe\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.1.2\", \"40gbe\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.1.3\", \"10gbe\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.1.5\", \"odu\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.1.9\", \"otu\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.5.2\", \"ots\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.5.5\", \"gopt\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.4.5.12\", \"nmc\", 12],\n        [\"1.3.6.1.4.1.42229.1.2.6.2\", \"xcon\", 11],\n        [\"1.3.6.1.4.1.42229.1.2.10.3\", \"ntp\", 11]\n    ]\n    \n    def bestMatch = \"\"\n    def bestType = \"unknown\"\n    def bestLen = 0\n    \n    patterns.each { item ->\n        def pattern = item[0]\n        def type = item[1]\n        def len = item[2]\n        if (oidValue.startsWith(pattern) && pattern.length() > bestMatch.length()) {\n            bestMatch = pattern\n            bestType = type\n            bestLen = len\n        }\n    }\n    \n    return [bestType, bestLen]\n}\n\n/**\n * Decodes ASCII characters embedded in an OID string\n */\ndef decodeAsciiFromOid(String oidValue) {\n    if (!oidValue) return null\n    \n    def parts = oidValue.split(\"\\\\.\")\n    def allMatches = []\n    \n    for (i in 0..<parts.size()) {\n        try {\n            def possibleLen = parts[i].toInteger()\n            \n            if (possibleLen >= 1 && possibleLen <= 50 && (i + possibleLen) < parts.size()) {\n                def chars = []\n                def valid = true\n                \n                for (j in 1..possibleLen) {\n                    def code = parts[i + j].toInteger()\n                    if (code >= 32 && code <= 126) {\n                        chars << (char)code\n                    } else {\n                        valid = false\n                        break\n                    }\n                }\n                \n                if (valid && chars.size() == possibleLen && possibleLen >= 3) {\n                    allMatches << chars.join(\"\")\n                }\n            }\n        } catch (Exception e) {\n            continue\n        }\n    }\n    \n    def portMatch = allMatches.find { it.contains(\"/\") }\n    if (portMatch) return portMatch\n    \n    def ipMatch = allMatches.find { it =~ /^\\d+\\.\\d+\\.\\d+\\.\\d+$/ }\n    if (ipMatch) return ipMatch\n    \n    return allMatches.max { it.length() }\n}\n\n/**\n * Parses numeric index based on entity type and known table OID length\n * Structure: table.entry.column.columnIndex.INDEX\n * So index starts at tableOidLen + 3\n */\ndef parseNumericIndex(String oidValue, String entityType, int tableOidLen) {\n    if (!oidValue || tableOidLen == 0) return null\n    \n    def parts = oidValue.split(\"\\\\.\").collect { \n        try { it.toInteger() } catch (Exception e) { 0 }\n    }\n    \n    // Index starts after: table + .1.1.1 (entry.column.columnIndex)\n    def indexStart = tableOidLen + 3\n    \n    if (indexStart >= parts.size()) return null\n    \n    def indexParts = parts[indexStart..<parts.size()]\n    \n    if (indexParts.size() < 2) return null\n    \n    // Format based on entity type\n    if (entityType == \"pluggable\") {\n        // Index: shelf.slot.subslot.port (e.g., 1.1.0.10 -> 1/1/10)\n        if (indexParts.size() >= 4) {\n            def shelf = indexParts[0]\n            def slot = indexParts[1]\n            def port = indexParts[3]\n            return \"${shelf}/${slot}/${port}\"\n        } else if (indexParts.size() >= 3) {\n            return \"${indexParts[0]}/${indexParts[1]}/${indexParts[2]}\"\n        }\n    } else if (entityType in [\"100gbe\", \"40gbe\", \"10gbe\"]) {\n        // Index: shelf.slot.subslot.port.subport (e.g., 1.1.0.5.4 -> 1/1/5)\n        if (indexParts.size() >= 4) {\n            def shelf = indexParts[0]\n            def slot = indexParts[1]\n            def port = indexParts[3]\n            return \"${shelf}/${slot}/${port}\"\n        } else if (indexParts.size() >= 3) {\n            return \"${indexParts[0]}/${indexParts[1]}/${indexParts[2]}\"\n        }\n    } else if (entityType == \"subcard\") {\n        // Index: shelf.slot.subslot (e.g., 1.3.3 -> 1/3.3)\n        if (indexParts.size() >= 3) {\n            return \"${indexParts[0]}/${indexParts[1]}.${indexParts[2]}\"\n        }\n    } else if (entityType in [\"odu\", \"otu\"]) {\n        // Index: shelf.slot.subslot.port.subport... (e.g., 1.1.0.4.0 -> 1/1/4)\n        if (indexParts.size() >= 4) {\n            def shelf = indexParts[0]\n            def slot = indexParts[1]\n            def port = indexParts[3]\n            return \"${shelf}/${slot}/${port}\"\n        } else if (indexParts.size() >= 3) {\n            return \"${indexParts[0]}/${indexParts[1]}/${indexParts[2]}\"\n        }\n    } else {\n        if (indexParts.size() >= 3) {\n            return \"${indexParts[0]}/${indexParts[1]}/${indexParts[2]}\"\n        } else if (indexParts.size() == 2) {\n            return \"${indexParts[0]}/${indexParts[1]}\"\n        }\n    }\n    \n    return null\n}\n\n/**\n * Extracts the base port (strips wavelength channel if present)\n */\ndef getBasePort(String portName) {\n    if (!portName) return null\n    def matcher = portName =~ /^(.+?)\\/(\\d{6})$/\n    if (matcher.matches()) {\n        return matcher[0][1]\n    }\n    return portName\n}\n\n// Track unique alarms\ndef seenAlarms = [:] as Map\n\nfmEntityData.each { index, value ->\n    def description = descriptionData.get(index)?.toString()?.trim() ?: \"Unknown Alarm\"\n    def oidValue = value.toString()\n    \n    // Detect entity type from table OID\n    def typeInfo = detectEntityType(oidValue)\n    def entityType = typeInfo[0]\n    def tableOidLen = typeInfo[1]\n    \n    // Try ASCII decode first\n    def entityName = decodeAsciiFromOid(oidValue)\n    \n    // If ASCII decode failed, try numeric parsing\n    if (!entityName) {\n        def numericPath = parseNumericIndex(oidValue, entityType, tableOidLen)\n        if (numericPath && entityType != \"unknown\") {\n            entityName = \"${entityType}-${numericPath}\"\n        } else if (numericPath) {\n            entityName = numericPath\n        }\n    }\n    \n    // Get base port (without wavelength)\n    def basePort = getBasePort(entityName)\n    \n    // Create deduplication key\n    def dedupeKey = \"${basePort ?: entityName ?: 'unknown'}::${description}\"\n    \n    if (seenAlarms.containsKey(dedupeKey)) {\n        seenAlarms[dedupeKey].suppressedCount++\n        return\n    }\n    \n    seenAlarms[dedupeKey] = [\n        index: index,\n        basePort: basePort,\n        entityName: entityName,\n        entityType: entityType,\n        description: description,\n        suppressedCount: 0\n    ]\n}\n\n// Output deduplicated alarms\nseenAlarms.each { key, alarm ->\n    def displayPort = alarm.basePort ?: alarm.entityName ?: \"Unknown\"\n    def displayName = \"${displayPort} - ${alarm.description}\"\n    \n    if (alarm.suppressedCount > 0) {\n        displayName = \"${displayName} (${alarm.suppressedCount + 1} channels)\"\n    }\n    \n    displayName = displayName.replaceAll(\"\\\\s+\", \" \").trim()\n    \n    println \"${alarm.index}##${displayName}##${alarm.description}\"\n}\n\nreturn 0"
    },
    "discoveryInterval": "0m",
    "enabled": true,
    "showDeletedInstanceDays": 0
  },
  "type": 0,
  "technicalNotes": "Enterprise OID: .1.3.6.1.4.1.42229\nMIB: CORIANT-GROOVE-MIB\nTable: standingConditionTable",
  "useWildValueAsUniqueIdentifier": false,
  "version": 1764794806,
  "registryMetadata": {
    "currentUuid": "Q-OdA6zTTlqqJp47S2c9KA",
    "originalUuid": "Q-OdA6zTTlqqJp47S2c9KA",
    "locatorId": "",
    "authorCompanyUuid": "c658eb28-8436-4591-b0b3-bd828174c599",
    "registryVersion": "2.2.0",
    "checksum": "58a1a1b2340614cb1bb7aef5d0e37aeb",
    "namespace": "",
    "registryId": "",
    "isChangedFromOrigin": false,
    "status": ""
  },
  "multiInstance": true,
  "integrationMetadata": {
    "publishedAtMS": 1764794866634,
    "authorCompanyUuid": "c658eb28-8436-4591-b0b3-bd828174c599",
    "namespace": "evoquedcs",
    "registryVersion": "2.2.0",
    "name": "",
    "checksum": "58a1a1b2340614cb1bb7aef5d0e37aeb",
    "registryId": "9518f377-38aa-47b8-83d3-23c6dbd75cb1",
    "isPrivate": true,
    "locator": "L4HG46",
    "lineageId": "Q-OdA6zTTlqqJp47S2c9KA",
    "status": "SECURITY_REVIEW"
  },
  "name": "Infinera_Groove_StandingAlarms",
  "collectionInterval": "3m",
  "dataSourceType": 1,
  "group": "SNMP",
  "headers": {
    "cache-control": "no-cache, no-store",
    "content-disposition": "attachment; filename=\"Infinera_Groove_StandingAlarms.json\"",
    "content-encoding": "gzip",
    "content-type": "application/json",
    "date": "Thu, 11 Dec 2025 02:37:06 GMT",
    "server": "LM",
    "strict-transport-security": "max-age=31536000; includeSubDomains",
    "vary": "accept-encoding",
    "x-content-type-options": "nosniff",
    "x-server-version": "230-8",
    "x-xss-protection": "0"
  },
  "config": {
    "transitional": {
      "silentJSONParsing": true,
      "forcedJSONParsing": true,
      "clarifyTimeoutError": false
    },
    "adapter": [
      "xhr",
      "http",
      "fetch"
    ],
    "transformRequest": [
      null
    ],
    "transformResponse": [
      null
    ],
    "timeout": 0,
    "xsrfCookieName": "XSRF-TOKEN",
    "xsrfHeaderName": "X-XSRF-TOKEN",
    "maxContentLength": -1,
    "maxBodyLength": -1,
    "env": {},
    "headers": {
      "Accept": "application/json, text/javascript, */*; q=0.01",
      "Content-Type": "application/json",
      "X-version": "4",
      "X-CSRF-Token": "55936C41312357A1C93772E31610ADFA"
    },
    "baseURL": "/santaba/rest",
    "paramsSerializer": {},
    "params": {},
    "method": "post",
    "url": "/exchange/toolbox/exchangeDataSources/21328165/file",
    "data": "{}",
    "allowAbsoluteUrls": true
  }
}